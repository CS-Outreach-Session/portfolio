# Dr Andrew Guest Academic Portfolio

## Role

I am a lecturer in the Computer Science department of York St John University.   

My main role is as Games Development Programme Lead, running the Games Development BSc(Hons) degree. This entails designing, developing and overseeing the Games Development specific modules. I recently took the Games degree through revalidation as part of the department's revalidations of its existing degrees.  

I am Academic Tutor for our games students, their first point of contact for any issues that are not module related and their second point of contact for module issues. This include issues to do with degree progression, resits, programme transfers and, where appropriate, pastoral issues related to student lives that affect their studies.   

I lecture on programming and games development topics. I run a module on object oriented programming in Java and most of the games modules we run (Games Fundamentals, Games Design, Game Engine Development, iOS Games Development). The revalidated Games Dev programme increases the number of games specific modules and my lecturing role will move to focusing on those module over the next three years.  

I supervise final year projects for our third year students.  

## Background

I graduated from Aberdeen University in 1996 with an honours degree in Computing Science. After graduation I worked in software development mostly in the oil industry in Aberdeen, supporting and developing systems for Shell and BP.  

I left industry due to health issues and went back to university in 2006 to study Computer Animation & Graphics Technology Applications at Teesside University. It was during this period I discovered a love of academia. After gaining my Masters I moved to Dundee to study for a PhD at Abertay University.  

My PhD was part of a research group entitled "The Emergence of Artificial Culture in Robot Societies", investigating if the dynamics of imitation in swarm systems could lead to the emergence of proto-cultural artifacts. My thesis examined how different types of imitation could affect the duplication of sound memes when the robots audibly imitated each other.  

Throughout my PhD I taught at various levels at Abertay. Initially I worked as a lab assistant for a variety of computing and games development modules, running tutorials and giving the occasional lecture. During my last three years at Abertay I developed, ran and assessed modules in Software Engineering and Computer Systems.  

I have played games of all kinds for as long as I can remember, board games from early childhood, video games from the late seventies and table-top RPGs since the early eighties. My time at Abertay (during my PhD) gave me the chance to get involved with teaching games development and that has become the focus of my academic career.  

I joined York St John at the start of the 2017/18 academic year.  I was
## Pedagogy / Teaching Issues

Pedagogically speaking the teaching of computer programming throws up a few issues.  

### Starting Point

Teaching in computing, at University level, faces a challenge that few other subjects have to deal with. Computing in secondary education varies greatly. Some schools have strong computing science programmes, some have taken an information technology route, and some have had no computing programme at all. This results in students leaving school with a range of computer science knowledge ranging from none at all to a thorough grounding in the basics, more than that for students that got the "coding bug" and have further developed their skills as a hobby. This range of ability level is common across all the subjects studied in school, some study history, some chemistry, some languages. Most subjects, at university level, can assume some expertise because the subject is well provided at secondary level (Maths, English, History, Geography, Chemistry, etc.), or work from the safe assumption that their students have little to no knowledge because the subject is not a school subject (Medicine. Law, etc).  

What is unusual is that the sporadic coverage of computing at secondary level means that universities have to start teaching computing, and coding specifically, assuming no previous knowledge but we do so in the knowledge that some of our students have a significant level of knowledge already. So we face the challenge of trying to engage and educate those with no previous subject knowledge while also engaging and providing value to those who already know the basics.  

The starting point for students on day one, term one, year one in computing ranges from students who have never used a computer, through those who have used a computer but never programmed or learned how a computer works, students who've done a little coding (enough to have a feel for what coding is like), up to students with a good grasp of the basics.  

The impact of this varies by module. For programming modules it matters a great deal, and at YSJ we have a strong thread of programming running through our Computing degrees. We also run modules on the impact of technology, research, and professional "soft skills", for these modules the range of prior experience is less significant. Or more accurately the range of prior skills is much smaller, to the point where it is no longer such a concern in teaching.  

**Differentiation (Tomlinson)**  

Tomlinson (p248) describes a *Differentiation* based approach where students are allowed to learn at their own pace based on their own knowledge and desires. **do students know enought to decide for themselves?**. Tomlinson recommends having extra activities for those who finish early. She also recommends allowing the more experienced students to assist the waker ones and working in pairs or groups. These suggestions work well in computing. A range of exercises can be prepared and students naturally work together in twos or threes. These groups form naturally, sometimes with one experienced student and one or two weaker ones, sometimes with two or three mid level students working together. This also matches up to an industry practice known as [pair programming](https://en.wikipedia.org/wiki/Pair_programming). 

### Continuous Incremental & Iterative Learning

Learning programming is an iterative process. The lessons/techniques learned in the first lesson are required knowledge for all subsequent lessons. Each lesson builds on the previous ones and feeds in to the subsequent ones. As such it is essential that students not only learn the knowledge but practice using it so it becomes internalised and they can use the early techniques instinctively while learning the later ones.  

Flexible teaching approach - need to be aware of what student are and aren't learning. Need to be flexible enough to speed up when concepts are learned quickly and (more often) slow down/repeat a concept which is providing troublesome.

Becoming an effective programmer is a process that develops through a number of stages.  

1. Basic conceptual understanding - what does the technique do? How does the technique do it? 
2. Technical knowledge - how is the basic technique implemented in the programming language?
3. Basic examples - examples of the use of the technique in code
4. Basic practice - student implements the basic technique
5. Expanded awareness - how/where/when can the technique be used beyond the basic implementation? When might it be used in practice?
6. Expanded examples - examples of the use of the technique in more complex situations
7. Expanded practice - students given more complex tasks without being told how/where to use the technique
8. Later practice - students guided/reminded to use the technique when developing later code/learning later techniques
9. Internalised practice - students use the technique when appropriate without being prompted to use it

However this isn't a simple linear path from 1 to 9. Steps 1 to 4 give the best foundation for true understanding but needn't occur in that order and different students learn best in different ways. Some need the basic concepts explaining first before they can begin to understand what code is doing. Others prefer to learn from the code examples first, developing their own understanding and then confirming it against the concept. Some students learn best by starting with where/when/why the technique would be used before learning the details of how it works or how to do it. Some even learn best when given a complete program that uses the technique and being left alone to examine the code to see how it works and teaching themselves the technique. There is often a final approach where a student already knows the technique but has never understood it or the theory behind it.    

Obviously it isn't possible to give a lecture to a class such that all approaches are covered. My approach is to try to structure lectures and lab exercises so that steps 1 to 7 are covered in that order but are covered clearly so that students can find their own way through the material depending on their individual styles.  

I find keeping the lecture portion as clear and simple as possible and then using a problem based approach as class exercises is generally the most effective approach for the majority of the students. Some students require more support usually in small groups or one to one tuition during lab sessions.  

### Game Module Approach

Game modules are distinct from other modules in their focus on games. Ideally games development students should always be making games. They need to learn through practice but they also need to develop a portfolio of work for their future careers. It is appropriate then that each games module should be built around the development of a game. My approach to this is that the assessment should be based on the development of a game (or game component). In addition, where possible, the games module material/teaching should be based around the development of a game (or games) as an example.  

### Module Planning

The process of developing a module involves identifying the objectives, content teaching methods and assessment of the module, either linearly (Tyler 1949) or more iteratively (Taba 1962, Stenhouse 1957). I like the idea of discovery learning in curriculum design (Bruner 1966) but I find that getting students to engage and drive their own learning can be difficult (first year students are exceptionally good at finding distractions!) and it can be easy to fall back on simple. structured, content driven lectures.  

Technical subjects, like programming, match well with level based taxonomies of learning (Bloom & Krathwohl 1956, Dave 1970). Coding is typically taught in such a manner - first students code by imitating what they are shown, this becomes internalised and can be replicated from memory, then as understanding of the underlying concept grows they are able to manipulate the code to achieve different effects. This eventually leads to a deeper understanding and the ability to form links with other concepts, leading to mastery of the concept. As an example, in code terms, they begin by replicating the code for a for loop that they have been shown, they memorise the code format, learn to manipulate it for more complex loops, learn how the for loop relates to other types of loops and eventually know how, when and why to use a loop.  

I believe that engagement and challenge are the two key factors in module design. Every module should engage the students interests, it should nudge or tempt them in to wanting to learn more. Each module should also challenge the students at an appropriate level for each student.   

## HEA Framework Dimensions

* [Areas of Activity](HEAFramework/AreasofActivity.md)
* [Core Knowledge](HEAFramework/CoreKnowledge.md)
* [Professional Values](HEAFramework/ProfessionalValues.md)
## Case Studies

* [Games Development Programme Revalidation](CaseStudies/GamesDevRevalidation.md)
* [Games Development Programme Lead](CaseStudies/GamesDevLead.md)

## Modules

### *My* Modules
#### Level 4

* [Games Fundamentals](modules/2022/Level4/GamesFundamentals.md)
* [Games Design](modules/2022/Level4/GamesDesign.md)

#### Level 5

* [Programming 03](modules/2017-2022/Programming03.md)

#### Level 6

* [Game Engine Development](modules/2017-2022/GameEngineDevelopment.md)
* [iOS Games Development](modules/2017-2022/Level6/iOSGamesDevelopment.md)
* [Major Project - Supervision](modules/2017-2022/Level6/MajorProjectSupervision.md)

### Other Modules

#### Level 4

* [Computer Games Fundamentals](modules/2017-2022/Level4/ComputerGamesFundamentals.md)
* [Programming 01](modules/2017-2022/Level4/Programming01.md)
* [Programming 02](modules/2017-2022/Programming02.md)

#### Level 5

* [Design Patterns](modules/2017-2022/DesignPatterns.md)
* [Professional Project](modules/2017-2022/Level5/ProfessionalProject.md)
* [Philosophies of Technology](modules/2017-2022/Level5/PhilosophiesofTech.md)

#### Level 6

* [HCI](modules/2017-2022/Level6/HCI.md)

