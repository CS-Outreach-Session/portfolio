# Pedagogy

Pedagogically speaking the teaching of computer programming throws up a few issues.  

### Starting Point

Teaching in computing, at University level, faces a challenge that few other subjects have to deal with. Computing in secondary education varies greatly. Some schools have strong computing science programmes, some have taken an information technology route, and some have had no computing programme at all. This results in students leaving school with a range of computer science knowledge ranging from none at all to a thorough grounding in the basics, more than that for students that got the "coding bug" and have further developed their skills as a hobby. This range of ability level is common across all the subjects studied in school, some study history, some chemistry, some languages. Most subjects, at university level, can assume some expertise because the subject is well provided at secondary level (Maths, English, History, Geography, Chemistry, etc.), or work from the safe assumption that their students have little to no knowledge because the subject is not a school subject (Medicine. Law, etc).  

What is unusual is that the sporadic coverage of computing at secondary level means that universities have to start teaching computing, and coding specifically, assuming no previous knowledge but we do so in the knowledge that some of our students have a significant level of knowledge already. So we face the challenge of trying to engage and educate those with no previous subject knowledge while also engaging and providing value to those who already know the basics.  

The starting point for students on day one, term one, year one in computing ranges from students who have never used a computer, through those who have used a computer but never programmed or learned how a computer works, students who've done a little coding (enough to have a feel for what coding is like), up to students with a good grasp of the basics.  

The impact of this varies by module. For programming modules it matters a great deal, and at YSJ we have a strong thread of programming running through our Computing degrees. We also run modules on the impact of technology, research, and professional "soft skills", for these modules the range of prior experience is less significant. Or more accurately the range of prior skills is much smaller, to the point where it is no longer such a concern in teaching.  

**Differentiation (Tomlinson)**  

Tomlinson (Tomlinson 1995, Tomlinson 2005) describes a *Differentiation* based approach where students are allowed to learn at their own pace based on their own knowledge and desires.  Tomlinson recommends having extra activities for those who finish early. She also recommends allowing the more experienced students to assist the waker ones and working in pairs or groups. These suggestions work well in computing. A range of exercises can be prepared and students naturally work together in twos or threes. These groups form naturally, sometimes with one experienced student and one or two weaker ones, sometimes with two or three mid level students working together. This also matches up to an industry practice known as [pair programming](https://en.wikipedia.org/wiki/Pair_programming). 

### Continuous Incremental & Iterative Learning

Learning programming is an iterative process. The lessons/techniques learned in the first lesson are required knowledge for all subsequent lessons. Each lesson builds on the previous ones and feeds in to the subsequent ones. As such it is essential that students not only learn the knowledge but practice using it so it becomes internalised and they can use the early techniques instinctively while learning the later ones.  

Flexible teaching approach - need to be aware of what student are and aren't learning. Need to be flexible enough to speed up when concepts are learned quickly and (more often) slow down/repeat a concept which is providing troublesome.

Becoming an effective programmer is a process that develops through a number of stages.  

1. Basic conceptual understanding - what does the technique do? How does the technique do it? 
2. Technical knowledge - how is the basic technique implemented in the programming language?
3. Basic examples - examples of the use of the technique in code
4. Basic practice - student implements the basic technique
5. Expanded awareness - how/where/when can the technique be used beyond the basic implementation? When might it be used in practice?
6. Expanded examples - examples of the use of the technique in more complex situations
7. Expanded practice - students given more complex tasks without being told how/where to use the technique
8. Later practice - students guided/reminded to use the technique when developing later code/learning later techniques
9. Internalised practice - students use the technique when appropriate without being prompted to use it

However this isn't a simple linear path from 1 to 9. Steps 1 to 4 give the best foundation for true understanding but needn't occur in that order and different students learn best in different ways. Some need the basic concepts explaining first before they can begin to understand what code is doing. Others prefer to learn from the code examples first, developing their own understanding and then confirming it against the concept. Some students learn best by starting with where/when/why the technique would be used before learning the details of how it works or how to do it. Some even learn best when given a complete program that uses the technique and being left alone to examine the code to see how it works and teaching themselves the technique. There is often a final approach where a student already knows the technique but has never understood it or the theory behind it.    

Obviously it isn't possible to give a lecture to a class such that all approaches are covered. My approach is to try to structure lectures and lab exercises so that steps 1 to 7 are covered in that order but are covered clearly so that students can find their own way through the material depending on their individual styles.  

I find keeping the lecture portion as clear and simple as possible and then using a problem based approach as class exercises is generally the most effective approach for the majority of the students. Some students require more support usually in small groups or one to one tuition during lab sessions.  

## K2 - Appropriate methods for teaching, learning and assessing in the subject area and at the level of the academic programme

Computing as an industry, especially software development, requires individual knowledge and ability, alongside teamwork which utilises differening knowledge and ability in team members. This poses a number of challenges teaching computing, especially in teaching programming. Is it possible to develop individual ability whilst also teaching efficient and smart use of differing knowledge in teams.  

Our approach is based around problem solving. Problem based learning is student focused and allows them to learn by doing. It is a form of Active learning - *"a method of learning in which students are actively or experientially involved in the learning process and where there are different levels of active learning, depending on student involvement."* (Bonwell & Eison 1991).

Concepts are presented as theory and with worked examples in lectures. Lab exercises then give the students chance to implement those theories themselves. The initial exercises are generally simple and straightforward but are followed up by exercises which present the students with a problem to solve with being explicit on how to solve it. The students need to work out how and when to use the concept (along with earlier concepts). At this stage we encourage students to work in twos or threes to understand the problem and develop a solution. This generally works well and students are able to bring different abilities and understanding of the concepts together to find solutions. This also nicely matches up to the industrial practice of Pair Programming.  

While we don't formally use the Maastrict 7-Jump (Wood 2003), this approach does mirror the process the students are taken through.  

**Maastrict 7-Jump**  

1. discuss the case and make sure everyone understands the problem
2. identify the questions that need to be answered to shed light on the case
3. brainstorm what the group already knows and identify potential solutions
4. analyse and structure the results of the brainstorming session
5. formulate learning objectives for the knowledge that is still lacking
6. do independent study, individually or in smaller groups: read articles or books, follow practicals or attend lectures to gain the required knowledge
7. discuss the findings

Initially I present the problem to the students (step 1). Informally, in their pairs the students analyse and discuss the problem, seeking a solution (steps 2-4). They attempt a solution, revising and reconsidering if it fails (steps 5 and 6, revisiting 2-4 if needed). As the students progress through the module(s) they will learn new concepts and learn how to use them alongside the current and previous concepts (steps 5-7). Students typically revise the whole process when working on the assessment.  

[Pedagogy](../CaseStudies/pedagogy.md)  

### Game Module Approach

Game modules are distinct from other modules in their focus on games. Ideally games development students should always be making games. They need to learn through practice but they also need to develop a portfolio of work for their future careers. It is appropriate then that each games module should be built around the development of a game. My approach to this is that the assessment should be based on the development of a game (or game component). In addition, where possible, the games module material/teaching should be based around the development of a game (or games) as an example.  

### Module Planning

The process of developing a module involves identifying the objectives, content teaching methods and assessment of the module, either linearly (Tyler 1949) or more iteratively (Taba 1962, Stenhouse 1957). I like the idea of discovery learning in curriculum design (Bruner 1966) but I find that getting students to engage and drive their own learning can be difficult (first year students are exceptionally good at finding distractions!) and it can be easy to fall back on simple. structured, content driven lectures.  

Technical subjects, like programming, match well with level based taxonomies of learning (Bloom & Krathwohl 1956, Dave 1970). Coding is typically taught in such a manner - first students code by imitating what they are shown, this becomes internalised and can be replicated from memory, then as understanding of the underlying concept grows they are able to manipulate the code to achieve different effects. This eventually leads to a deeper understanding and the ability to form links with other concepts, leading to mastery of the concept. As an example, in code terms, they begin by replicating the code for a for loop that they have been shown, they memorise the code format, learn to manipulate it for more complex loops, learn how the for loop relates to other types of loops and eventually know how, when and why to use a loop.  

I believe that engagement and challenge are the two key factors in module design. Every module should engage the students interests, it should nudge or tempt them in to wanting to learn more. Each module should also challenge the students at an appropriate level for each student.   

### ds
Computing as an industry, especially software development, requires individual knowledge and ability, alongside teamwork which utilises differening knowledge and ability in team members. This poses a number of challenges teaching computing, especially in teaching programming. Is it possible to develop individual ability whilst also teaching efficient and smart use of differing knowledge in teams.  

Our approach is based around problem solving. Problem based learning is student focused and allows them to learn by doing. It is a form of Active learning - *"a method of learning in which students are actively or experientially involved in the learning process and where there are different levels of active learning, depending on student involvement."* (Bonwell & Eison 1991).

Concepts are presented as theory and with worked examples in lectures. Lab exercises then give the students chance to implement those theories themselves. The initial exercises are generally simple and straightforward but are followed up by exercises which present the students with a problem to solve with being explicit on how to solve it. The students need to work out how and when to use the concept (along with earlier concepts). At this stage we encourage students to work in twos or threes to understand the problem and develop a solution. This generally works well and students are able to bring different abilities and understanding of the concepts together to find solutions. This also nicely matches up to the industrial practice of Pair Programming.  

While we don't formally use the Maastrict 7-Jump (Wood 2003), this approach does mirror the process the students are taken through.  

**Maastrict 7-Jump**  

1. discuss the case and make sure everyone understands the problem
2. identify the questions that need to be answered to shed light on the case
3. brainstorm what the group already knows and identify potential solutions
4. analyse and structure the results of the brainstorming session
5. formulate learning objectives for the knowledge that is still lacking
6. do independent study, individually or in smaller groups: read articles or books, follow practicals or attend lectures to gain the required knowledge
7. discuss the findings

Initially I present the problem to the students (step 1). Informally, in their pairs the students analyse and discuss the problem, seeking a solution (steps 2-4). They attempt a solution, revising and reconsidering if it fails (steps 5 and 6, revisiting 2-4 if needed). As the students progress through the module(s) they will learn new concepts and learn how to use them alongside the current and previous concepts (steps 5-7). Students typically revise the whole process when working on the assessment.  


### video

In Computing at YSJ we have a wide range of students. Computing Science is not widely taught at school level so we have to assume no knowledge of computing and programming at the start of first year. However some students do study computer science and programming at school and others have taught themselves to program. This leads to a wide range of ability levels in first year students (who have come directly from school). Similarly mature students, and others who have not come directly from school, have a wide range of experience and knowledge. The challenge here is in getting all of the students to the same base level by the end of first year, getting those with no experience programming up to speed while maintaining the engagement and providing some challenge to those with significant experience.  

We have found that problem based learning is the best approach. We can provide a range of problems to the students that cover the course material and additional problems that give the experienced students the opportunity to push themselves further.  

Having the students work together in twos or threes works well with the problem based approach. Working together allows students with differing knowledge and understanding to work together to find solutions. Additionally many of the more knowledgable students enjoy helping others learn.

We have resources in place to help students with learning challenges. Our timetable is designed with some flexibility to help carers schedule their studies. We use Learning Support Plans (LSPs) to help students with specific requirements.


## References

* Barrows, Howard S. (1996). "Problem-based learning in medicine and beyond: A brief overview". New Directions for Teaching and Learning. 1996 (68): 3–12. doi:10.1002/tl.37219966804.
* Bloom, B. and Krathwohl, D., 1956, *Taxonomy of Educational Objectives*, London: Longman
* Bonwell, C. C., & Eison, J. A. (1991). Active Learning: Creating Excitement in the Classroom. ASHE-ERIC Higher Education Report, Washington DC: School of Education and Human Development, George Washington University.
* Dave, R.H., 1970, *Psychomotor Levels* in R.J. Armstrong (ed) *Developing and Writing Behavioural Objectives* (pp.20-1), Tucson, AZ: Educational Innovators Press
* Hogue, A., Kapralos, B. and Desjardins, F. (2011), "The role of project‐based learning in IT: A case study in a game development and entrepreneurship program", Interactive Technology and Smart Education, Vol. 8 No. 2, pp. 120-134
* Stenhouse, L., 1975, *An Introduction to Curriculum Research and Development*, London: Hieneman Educational
* Taba H, 1962, *Curriculum Development Theory and Practice*, Crow's Nest, NSW: Allen & Unwin
* Tomlinson, C.A., 1995, *How to Differentiate Instruction in Mixed-Ability Classrooms*, Alxeandria, VA:ASCD
* Tomlinson, C.A., 2005, *Differentiation in Practice*, Alxeandria, VA:ASCD
* Tyler R.W., 1949, *Basic Principles of Curriculum and Instruction*, Chicago, University of Chicago Press
* Wood, D. F. (2003). "ABC of learning and teaching in medicine: Problem based learning". BMJ. 326 (7384): 328–330. doi:10.1136/bmj.326.7384.328. PMC 1125189. PMID 12574050.
* "Problem-Based Learning - Education - Maastricht University". www.maastrichtuniversity.nl. Retrieved 2022-08-15.