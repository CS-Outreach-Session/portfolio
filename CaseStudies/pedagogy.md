# Pedagogy

Pedagogically speaking the teaching of computer programming throws up a few issues.  

### Starting Point

Teaching in computing, at University level, faces a challenge that few other subjects have to deal with. Computing in secondary education varies greatly. Some schools have strong computing science programmes, some have taken an information technology route, and some have had no computing programme at all. This results in students leaving school with a range of computer science knowledge ranging from none at all to a thorough grounding in the basics, more than that for students that got the "coding bug" and have further developed their skills as a hobby. This range of ability level is common across all the subjects studied in school, some study history, some chemistry, some languages. Most subjects, at university level, can assume some expertise because the subject is well provided at secondary level (Maths, English, History, Geography, Chemistry, etc.), or work from the safe assumption that their students have little to no knowledge because the subject is not a school subject (Medicine. Law, etc).  

What is unusual is that the sporadic coverage of computing at secondary level means that universities have to start teaching computing, and coding specifically, assuming no previous knowledge but we do so in the knowledge that some of our students have a significant level of knowledge already. So we face the challenge of trying to engage and educate those with no previous subject knowledge while also engaging and providing value to those who already know the basics.  

The starting point for students on day one, term one, year one in computing ranges from students who have never used a computer, through those who have used a computer but never programmed or learned how a computer works, students who've done a little coding (enough to have a feel for what coding is like), up to students with a good grasp of the basics.  

The impact of this varies by module. For programming modules it matters a great deal, and at YSJ we have a strong thread of programming running through our Computing degrees. We also run modules on the impact of technology, research, and professional "soft skills", for these modules the range of prior experience is less significant. Or more accurately the range of prior skills is much smaller, to the point where it is no longer such a concern in teaching.  

**Differentiation (Tomlinson)**  

Tomlinson (Tomlinson 1995, Tomlinson 2005) describes a *Differentiation* based approach where students are allowed to learn at their own pace based on their own knowledge and desires.  Tomlinson recommends having extra activities for those who finish early. She also recommends allowing the more experienced students to assist the waker ones and working in pairs or groups. These suggestions work well in computing. A range of exercises can be prepared and students naturally work together in twos or threes. These groups form naturally, sometimes with one experienced student and one or two weaker ones, sometimes with two or three mid level students working together. This also matches up to an industry practice known as [pair programming](https://en.wikipedia.org/wiki/Pair_programming). 

### Continuous Incremental & Iterative Learning

Learning programming is an iterative process. The lessons/techniques learned in the first lesson are required knowledge for all subsequent lessons. Each lesson builds on the previous ones and feeds in to the subsequent ones. As such it is essential that students not only learn the knowledge but practice using it so it becomes internalised and they can use the early techniques instinctively while learning the later ones.  

Flexible teaching approach - need to be aware of what student are and aren't learning. Need to be flexible enough to speed up when concepts are learned quickly and (more often) slow down/repeat a concept which is providing troublesome.

Becoming an effective programmer is a process that develops through a number of stages.  

1. Basic conceptual understanding - what does the technique do? How does the technique do it? 
2. Technical knowledge - how is the basic technique implemented in the programming language?
3. Basic examples - examples of the use of the technique in code
4. Basic practice - student implements the basic technique
5. Expanded awareness - how/where/when can the technique be used beyond the basic implementation? When might it be used in practice?
6. Expanded examples - examples of the use of the technique in more complex situations
7. Expanded practice - students given more complex tasks without being told how/where to use the technique
8. Later practice - students guided/reminded to use the technique when developing later code/learning later techniques
9. Internalised practice - students use the technique when appropriate without being prompted to use it

However this isn't a simple linear path from 1 to 9. Steps 1 to 4 give the best foundation for true understanding but needn't occur in that order and different students learn best in different ways. Some need the basic concepts explaining first before they can begin to understand what code is doing. Others prefer to learn from the code examples first, developing their own understanding and then confirming it against the concept. Some students learn best by starting with where/when/why the technique would be used before learning the details of how it works or how to do it. Some even learn best when given a complete program that uses the technique and being left alone to examine the code to see how it works and teaching themselves the technique. There is often a final approach where a student already knows the technique but has never understood it or the theory behind it.    

Obviously it isn't possible to give a lecture to a class such that all approaches are covered. My approach is to try to structure lectures and lab exercises so that steps 1 to 7 are covered in that order but are covered clearly so that students can find their own way through the material depending on their individual styles.  

I find keeping the lecture portion as clear and simple as possible and then using a problem based approach as class exercises is generally the most effective approach for the majority of the students. Some students require more support usually in small groups or one to one tuition during lab sessions.  

### Game Module Approach

Game modules are distinct from other modules in their focus on games. Ideally games development students should always be making games. They need to learn through practice but they also need to develop a portfolio of work for their future careers. It is appropriate then that each games module should be built around the development of a game. My approach to this is that the assessment should be based on the development of a game (or game component). In addition, where possible, the games module material/teaching should be based around the development of a game (or games) as an example.  

### Module Planning

The process of developing a module involves identifying the objectives, content teaching methods and assessment of the module, either linearly (Tyler 1949) or more iteratively (Taba 1962, Stenhouse 1957). I like the idea of discovery learning in curriculum design (Bruner 1966) but I find that getting students to engage and drive their own learning can be difficult (first year students are exceptionally good at finding distractions!) and it can be easy to fall back on simple. structured, content driven lectures.  

Technical subjects, like programming, match well with level based taxonomies of learning (Bloom & Krathwohl 1956, Dave 1970). Coding is typically taught in such a manner - first students code by imitating what they are shown, this becomes internalised and can be replicated from memory, then as understanding of the underlying concept grows they are able to manipulate the code to achieve different effects. This eventually leads to a deeper understanding and the ability to form links with other concepts, leading to mastery of the concept. As an example, in code terms, they begin by replicating the code for a for loop that they have been shown, they memorise the code format, learn to manipulate it for more complex loops, learn how the for loop relates to other types of loops and eventually know how, when and why to use a loop.  

I believe that engagement and challenge are the two key factors in module design. Every module should engage the students interests, it should nudge or tempt them in to wanting to learn more. Each module should also challenge the students at an appropriate level for each student.   

## References

* Barrows, Howard S. (1996). "Problem-based learning in medicine and beyond: A brief overview". New Directions for Teaching and Learning. 1996 (68): 3–12. doi:10.1002/tl.37219966804.
* Bloom, B. and Krathwohl, D., 1956, *Taxonomy of Educational Objectives*, London: Longman
* Bonwell, C. C., & Eison, J. A. (1991). Active Learning: Creating Excitement in the Classroom. ASHE-ERIC Higher Education Report, Washington DC: School of Education and Human Development, George Washington University.
* Dave, R.H., 1970, *Psychomotor Levels* in R.J. Armstrong (ed) *Developing and Writing Behavioural Objectives* (pp.20-1), Tucson, AZ: Educational Innovators Press
* Hogue, A., Kapralos, B. and Desjardins, F. (2011), "The role of project‐based learning in IT: A case study in a game development and entrepreneurship program", Interactive Technology and Smart Education, Vol. 8 No. 2, pp. 120-134
* Stenhouse, L., 1975, *An Introduction to Curriculum Research and Development*, London: Hieneman Educational
* Taba H, 1962, *Curriculum Development Theory and Practice*, Crow's Nest, NSW: Allen & Unwin
* Tomlinson, C.A., 1995, *How to Differentiate Instruction in Mixed-Ability Classrooms*, Alxeandria, VA:ASCD
* Tomlinson, C.A., 2005, *Differentiation in Practice*, Alxeandria, VA:ASCD
* Tyler R.W., 1949, *Basic Principles of Curriculum and Instruction*, Chicago, University of Chicago Press
* Wood, D. F. (2003). "ABC of learning and teaching in medicine: Problem based learning". BMJ. 326 (7384): 328–330. doi:10.1136/bmj.326.7384.328. PMC 1125189. PMID 12574050.
* "Problem-Based Learning - Education - Maastricht University". www.maastrichtuniversity.nl. Retrieved 2022-08-15.